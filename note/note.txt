安装软件
配置java开发环境
配置git环境
创建git仓库
Java基础
  编程语言
    编码
      idea、vscode、vim、文本文档写代码
    编译
      使用 javac 去编译
      javac HelloWorld.java
      会生成同名的字节码文件
    运行
      使用 java 命令 去运行
      java HelloWorld
      注意：不需要加.class
  1991年
相对路径
  .
  绝对路径
  C:
  D:
  /

跨平台
  高级编程语言的编码运行步骤
    编码
    编译
    运行
  高级语言的编译方式分为三种
    编译型
      使用专门的编译器，针对特定的操作系统，将源代码 "翻译"成为机器码，并包装成该平台能识别的可执行程序（生成新文件）
      C C++
    解释型
      有专门的解释器，将源码解释成特定平台的机器码，并且立即执行，不会生成新文件
      就是将编译型语言的编译和执行结合成一步同时进行
      缺点：效率低
      Python、Shell等
    混合型
      编译+解释
      源码要经过编译，生成与平台无关的字节码.class文件，不是可执行程序
      需要jvm去解释执行（java为不同的操作系统提供了不同的虚拟机）
      Java 
  Java跨平台的原理
    Write Once , Run any Where

常用命令
  javac 编译命令
    格式 javac [-d 目录路径] 文件名.java
    作用 编译源码文件，获得字节码文件 可选：将字节码文件存放到-d后面指定的位置
    使用 
    javac HelloWorld.java // 不指定目录.class存放到当前文件
    javac -d obj/ HelloWorld.java
    // 将编译后的.class存放到obj目录下
  java 运行的命令
    格式 java [-cp .class文件的目录] 类名
    作用 运行字节码文件 可选：从指定路径查找要运行的文件
    使用
      java HelloWorld
      java -cp obj/ HelloWorld
  package
    Table类
    Table类

    定义格式：
      package 包名；
      包名一般是公司域名的反写；
    要求：
      package语句必须是程序的第一条可执行代码
      package语句在一个Java文件中最多有一条
      package语句在一个Java文件可以没有

      这个包名的代码package com.briup; 编译后 字节码文件会存放到
      com/briup下
    场景
      教务系统
        学生管理
          新增 修改 删除 查询
        教师管理
          新增 修改 删除 查询
      package 按角色去分模块
        com.briup.students;
          AddStudent
          EditStudent
          DeleteStudent
          UpdateStudent
        com.briup.teachers;
          AddTeacher
          EditTeacher
          DeleteTeacher
          UpdateTeacher
      package 按功能去分模块
        com.briup.add;
          addStudent;
          addTeacher;
        com.briup.edit;
          editStudent;
          editTeacher;
        com.briup.delete;
          deleteStudent;
          deleteTeacher;
        com.briup.update;
          updateStudent;
          updateTeacher;
  导包
    import 包名.类名;
    import java.util.Scanner;
    不需要导包就可以使用的
      java.lang
  API文档
    https://docs.oracle.com/javase/8/docs/api/index.html
  JVM
  垃圾回收器

注释
  // 单行注释 单行注释可以嵌套使用
  // public static void main(String[] args) {
  //   // 输出 HelloWorld
  //   System.out.println("HelloWorld");
  // }
  /*
    多行注释 多行注释不能嵌套多行注释
    多行注释 一般用于大段的业务描述内容
  */
  /**
    文档注释
  */
    
编码习惯-编程规范
  注释内容要写的尽量详细
  编译时，编译器会忽略注释内容
  初学者写代码的时候，先把思路用注释写下来，然后再补充代码
关键字
  定义：被java赋予特殊含义的单词
  常用的代码编辑器对关键字有高亮显示
保留字
  定义：
    暂时还没被java赋予特殊含义的单词
    将来有可能
    或者已经被其他编程语言设置为关键字
    比如const 在JavaScript中的关键字
标识符（变量、常量、方法的名字）
  命名规则
    1. 不能使用java中的关键字和保留字
    2. 可以由字母、数字、下划线和$组成
    3. 数字不能放开头
    4. 大小写敏感 a A
    5. 长度没有限制
编码习惯-编程规范
  命名规则：
    类和接口
      每个单词的首字母都大写（大驼峰）
      class Hello
      class HelloWorld
      class HelloMyWorld
    方法和变量
      首字母小写，第二个单词开始每个首字母大写（小驼峰）
      int num;
      getStudentById();
    常量
      全词大写 多个单词之间用_分隔
      LIGHT_COLOR 
      MAX_NUM 
    临时变量 一般用下划线开头
      _a
    $ 尽量不用
  思考？
    _和$可以单独作为变量名吗？
    int _ = 0;
    int $ = 0;
变量和常量的定义 
  常量
    定义： 在程序运行中，他的值不可以发生改变
      除了null，其他常量可以直接用输出语句输出
    分类
      字面值常量
        字符串常量
          用""扩起来的0个或者1个或者多个字符
          "" 
          "0" 
          "hello" 
          "a"
        整数常量
          0 1 2 3 99 -10 -19
        小数常量
          0.1 -1.1
        字符常量''单引号扩起来的单个字符
          'a' 'B' '你' '好'
        布尔常量
          true false
        空常量
          null
      自定义常量
    声明final关键字
      final int NUM_A = 1;
      类的常量定义在main的外部
      const 在JavaScript中声明常量的关键字
  变量 
    定义 用于储存值的一种容器 
      强类型语言：比如在java中 声明变量需要指定他的数据类型，并且这个类型不能更改了
        int a;
        a = 10;
        a = 10.1;// 编译时错误
      弱类型语言中：比如javascript 声明变量不需要指定数据类型,这个类型赋值时确定
      let a;
      a = 10;
      a = 10.1;
      a = true;
      a = {name:"张三",age:12};
      a = [1,2,3,4,5,6,7,{name:"张三",age:12},[],true]    声明
      int a = 10; // 声明和初始化
      或者
      int a; // 声明
      a = 10; // 初始化
    注意：
      java中变量一定要先声明 再赋值 再使用
        S.o.p(a);// a?
        int a;

        int a;
        S.o.p(a); // a=?
        a = 1;
数据类型
  基本数据类型
    整型
      int   a = 20;
      long  b = 20L; b = 20l;
      byte 
      short
    浮点型
      double a = 1.0D; a = 1.0d;
      float  a = 1.0F; a = 1.0f;
    字符型
      char 单引号扩起来的单个字符
      不可以为空单引号
    布尔型
      boolean(值：true false)
  引用数据类型
    类 
      String
    数组
    接口

  比特位：bit 是计算机存储信息的最小单位 二进制 0 1
  字节byte 是计算机分配内存的最小单位 通常用B表示
  1byte == 8bits
转义字符
  \
  \n 换行
  \t 缩进
  \\ \
  \'
  \" 
  写代码输出一下自己电脑上jdk的bin目录的路径
进制
  二进制    由0 1 组成 逢2进1
    0b1  0B0 
    0：0b0
    1：0b1
    2：0b10
    3：0b11
    4：0b100  
  八进制    由0-7组成 逢8进1
    00 07 
    7:07
    8:010
    9:011
  十进制    由0-9组成 逢10进1
   9     
   8+1 = 9 
   9+1 = 10 
  十六进制  由0-9 abcdef 不区分大小写 逢16进1
    10:0x0a
    11:0x0b
    17:0x11
    18:0x12
进制转换    
  十进制转二进制 除二取余法
  十进制转八进制 除八取余法
  十进制转十六进制 除十六取余法

    20
  二进制   ： 
  1. 20 ÷ 2 = 10 ... 0
  2. 10 ÷ 2 = 5  ... 0
  3.  5 ÷ 2 = 2  ... 1
  4.  2 ÷ 2 = 1  ... 0
  5.  1 ÷ 2 = 0  ... 1
  6. 结束 0b10100
  八进制   ：
  1. 20 ÷ 8 = 2 ... 4
  2.  2 ÷ 8 = 0 ... 2
  3. 结束 024
  十六进制 ：
  1. 20 ÷ 16 = 1 ... 4
  2.  1 ÷ 16 = 0 ... 1
  3. 结束 0x14

  0x99 转为十进制
    9 × 16 1次方 144
    9 × 16 0次方 9
    144+9
数据类型转换
  数据类型表示范围
  double > float > long > int > short > byte
                                char

  隐式类型转换
    在赋值过程中 小数据类型的值或者变量可以直接赋值给大类型变量，类型会自动转换
    大类型赋值给小类型可能会丢失精度 所以编译错误
    byte\short\char类型在做算术运算时会自动提升为int类型 然后再参与计算
    各种类型的值都参与运算时，范围小的会自动提升为范围大的，然后再运算

  强制类型转换（显式类型转换）
    定义
      赋值过程中如果大类型的值赋值给小类型变量，编译报错，可以使用强制类型转换
    格式
      float float1 = (float)3.14;
      float float2 = (float)((byte1 - 5) * short1 + double1);
    强制类型转换的时候 注意值的一个问题
操作符
  定义
    对于字面值常量或变量进行操作的符号
    也叫运算符
表达式
  定义
    用操作符将字面值常量或者变量连接起来的式子 叫表达式
运算符的分类
  算术运算符
    + - * / %
    %
      求余运算，结果正负符号只跟表达式运算符左边的操作数的符号有关
    + 
      表达式中只要有字符串参与，得到的结果都是字符串
      字符串加其他任意类型数据，结果都是字符串
      注意区分字符串和字符
    自增自减++ --
      前置
        ++a
      后置
        a++
  赋值运算符
    = *= <<= &= 等
    +=、-=、*=、/= 等扩展的赋值运算符，隐含了强制类型转换
    s += 5; // s = (short)(s + 5);
  比较、条件、关系 运算符 
    > < >= <= == !=  
    // ！！在js中，不是java！！
    == !=    判断值是否相同
    === !==  判断类型是否相同，再判断值

    从键盘录入两个整型数字，比较其大小，输出结果 
  逻辑操作符
    && 与运算 带逻辑短路
     boolean flag =  (2 > 1) && (3 > 2)
      同真则真
      2 > 3 && 3 > 2
      2 > 1 && 3 > 4
      有假则假
    & 与运算
    ||带逻辑短路 
      true || false 结果为 true
      false || true 结果为 true
      有真则真
      false || false 结果为 false
      同假则假
    | 或运算
    ! 非 取反
     !true  
    ^ 异或
      如果两个数都是0 那么结果就是0
      如果两个数都是1 那么结果就是0
      如果两个一个为0一个为1 那么结果就是1
  三目运算符
    表达式?语句1:语句2
    书写简单，可读性比较低，不建议使用
  移位操作符
    >> << >>>
  位操作符 
    & | 
    从键盘录入两个整型值，判断能否被3和5整除
  instanceof
    是一个二元操作符
    用于检查对象是否是特定类型的实例；返回值是boolean类型
流程控制
  顺序执行
  分支结构
    if(){

    }else{

    }
    if-else if-else
    switch case
      switch()
        case 1:
          语句体1;
          break;
        case 2:
          语句体2;
          break;
        ...
        default:
          所有条件都不匹配，执行这里的语句;
    如果满足条件的case语句没有加break，那么代码会顺序往下执行，直到遇到break，如果一直没有break，那么会执行default后结束
  循环结构
    for 
      for(初始化语句；条件判断语句；条件控制语句){
        // 循环语句体
      }
      // 死循环
      for(;;){

      }
    while 
      while(条件判断语句){
        循环语句
        条件控制语句
      }
      // 死循环
      while(true){

      }
    do-while
      do{
        循环语句
        条件控制语句
      }while(条件判断语句)
      // 死循环
      do{
        
      }while(true)
    循环中的几个关键字
      break; 
        跳出当前循环
        循环语句遇到break关键字，循环直接结束
      continue;
        结束本次循环，进入到下一次循环
      label;
        代码中出现多层循环嵌套，label标签配合break关键字，可以使程序从内部循环中跳出
        如果想让break或continue针对某一个指定的循环起作用，那么可以使用label标签 给循环起名字，然后 使用break或continue加上label标签名即可。
    循环嵌套
      一个循环内部可以嵌套另一个或者多个循环
      双层for循环
方法 
  就是完成特定功能的代码块
  通过方法的定义和调用，可以大大提高代码的复用性和可读性   
  定义格式：
    修饰符  返回值类型 方法名  形参列表 形式参数列表
    public void     main  (){
      // 方法体

    }
    public int getSum(int a,int b){
      return a + b;
    }
    getSum(1,2);
  规范
    小驼峰命名法 main getStudentById getAvg
    见名知意 
方法重载
  同一个类中，如果函数名相同，但是参数列表不同（参数的数据类型不同、参数的个数不同），就构成方法的重载
  重载与返回值类型无关
数组
  表示一块连续的内存空间
  可以存储多个元素
  要求元素的数据类型一致
  数组定义的方式
    // 数据类型[] 数组名
    int[] arr;
    double[] arr;
    // 数据类型 数组名[]
    int arr[]
    double arr[]
    数组在没有初始化的时候不能使用
    数组长度
      arr.length 是一个属性 不是方法
      必须在创建数组对象时就明确指定
      一旦确定，无法改变
      >=0 不能为负数
    数组的下标从0开始 数组的下标最大值是 length - 1;
    数组异常
      数组下标越界
        java.lang.ArrayIndexOutOfBoundsException 
      空指针异常
        java.lang.NullPointerException
    数组的默认值
      动态初始化后的数组会有默认值 
        int           0
        double float  0.0
        char          \u0000 
        boolean       false
        String        null
  数组初始化
    动态初始化
      int[] arr1 = new int[3];
    静态初始化  
      int[] arr2 = new int[]{1, 2, 3, 4, 5};
      int[] arr3 = {1, 2, 3, 4, 5};
      注意错误写法
  内存空间
  使用
    工具类
      注意导包
      java.util.Arrays 包含了操作数组的很多方法
        Arrays.copyOf(array,10);
        Arrays.toString(array);
        Arrays.sort(arr1);  
        Arrays.fill(arr1,10);
  数组拷贝
    数组的长度不能更改，但是如果有更多的元素存入数组，可以创建一个新的更大的数组，将旧的数组中的元素放进去，然后再放新数组元素
    java.lang.System 中 有个方法 
    arraycopy 可以实现复制数组中的元素的功能
    [0,1,2,3]
    [0,0,0,0,0,0,0,0,0,0]
    [0,1,2,0,0,0,0,0,0,0]
    arraycopy(
    老数组,
    int 从哪里开始复制, 0
    新数组,
    int 复制到哪里,0
    int 长度,3
    )
  二维数组
    方式1 
      数据类型[][] 数组名 = new 数据类型[一维长度m][二维长度n];
      m表示一维长度
      n表示二维长度
    方式2
      数据类型[][] 数组名 = new 数据类型[一维长度m][];

    元素的访问
      
    元素的赋值
可变参数列表
  public static void myAdd(数据类型... 参数名){
    求和；
  }
  public static void myAdd(int... a){
    求和；
  }
  可变参数列表本质上是一个数组，方法中使用可变参数列表，比用数组作参数功能更强大。
  可变参数和普通参数共存的时候，可变参数必须放到最后一个参数的位置
  可变参数可以接受0-n个参数
  可变参数可以接受数组
面向过程
  强调按步骤实现功能，先分析解决问题要经过的步骤，然后定义方法实现每个步骤的功能，然后依次调用方法，去解决问题
面向对象
  将大问题拆分成小问题，借助不同的对象去解决，最终实现功能。
  C++ python java
  创建对象，使用对象，指挥对象去实现功能
面向对象的语言特征
面向对象语言的三大特征
  继承、封装、多态
对象的理解
  任何事物都是一个对象（object）
  对象由对象组成
  每个对象都有属性（静态的描述信息）、行为（动态的功能描述）
  具有相同属性和行为的对象可以归为一类
类的定义
  具有相同属性和行为的对象可以归为一类，类在
  java中是一种数据类型
类的组成
  属性
    指这类事物的静态特征
  方法（行为）
    事物所具有的动态功能  
  类 是对现实生活中 具有共同属性和行为的事物的抽象
  类是对象的数据类型 
  类是对象的抽象，对象是类的实例
类的定义格式
  public 权限修饰符 class 数据类型 Test 类名{
    // 属性
    权限修饰符 数据类型 变量名；
    public int a;
    // 功能（方法、行为）
    权限修饰符 返回值数据类型 方法名(形参列表){
      // 方法体语句
    }
    // 构造器、构造方法 创建对象需要用到
  }
变量类型
  成员变量
    定义在类中，方法外；
    在堆内存
    成员变量具有默认值
    生命周期：随着对象的存在而存在
  局部变量
    定义在方法中，或者方法的形参列表上；
    在栈内存
    没有默认值
    生命周期：随着方法的调用而生成，方法调用完毕消失
封装
  是面向对象语言的三大特征，另外两个是继承和多态
  封装 隐藏对象的属性和实现的细节 仅对外提供公共的访问方式
    提高安全性
    用户不需要知道内部具体复杂的实现。只需要使用对应的功能即可
  封装的原则
    把不需要对外提供的内容隐藏起来
    把属性隐藏掉，提供方法来修改，保证数据的安全
      属性：
        余额
      stu1.name = "张三";
      card.balance = 10000;
  封装的实现
    1. 用 private 修饰成员属性（成员变量）
    2. 提供对应的公开的 public set和 public get方法
this关键字
  this关键字可以用来区分局部变量和成员变量

  public void setId(String id){
    this.id = id; // this.id 就是成员变量
  }
  public void setId(String newId){
    id = newId; // id 就是成员变量
  }
构造函数（构造方法）
  构造方法可以对对象进行初始化操作
  当为对象开辟内存空间时，就给对象的成员变量赋初始值
  在创建对象的时候，每创建一次对象就会执行一次构造方法
  构造方法不能手动调用
  用户如果没有写无参构造器，那么系统会默认提供一个；
  当用户有写无参构造器，系统不提供了。
  当用户有写了其他有参参构造器，系统也不提供无参构造器了。
  在构造方法中，可以借助this调用其他构造方法，
  必须放到构造方法中的第一行有效代码上
  构造方法可以重载
  构造方法可以重写吗？
构造方法的格式
java程序 一般会有测试类和基础类的区分
  测试类
    包含main方法，作为程序的入口
  基础类
    Student
    Teacher 
    Table类  
静态成员：
  静态数据成员是属于类的，并且为这个类所有对象共享，只占一块内存空间、
  随着类的加载而先创建出来，然后对象才被创建出来
  一般是通过类名去访问、修改（推荐），也可以通过对象去访问、修改(不推荐)
  School.library = "栋梁图书馆";
  s3.library = "启强图书馆";
  System.out.println("s3.library："+s3.library);
  静态成员初始化的时候有默认值
静态方法：
    public static void test(){}
    可以使用类名调用（推荐），也可使用对象调用
    和普通方法的区别
      1. 静态方法只能访问静态成员变量
      2. 非静态方法能访问静态成员变量，也能访问非静态成员
      3. 静态方法没有this关键字
    尽量不要在构造器中操作静态成员变量
代码块
  在java中用{}扩起来的代码叫代码块，分类
    1. 局部代码块
        位置：类的方法中定义的 叫局部代码块
        {
          语句体;
        }
        作用：
          限定变量的生命周期，尽早释放，遇到}时释放，提高内存效率
    2. 构造代码块
      位置：类中 方法外
      {
        语句体;
      }
      作用：可以把构造方法中，相同的代码提取到这里，提高代码的复用性
      特点：构造方法执行前会执行他
      ？系统默认的构造方法执行前会执行他吗？
    3. 静态代码块
       位置：类中 方法外
      static {
        语句体;
      }
      作用：可以在类加载时 给静态成员变量赋值
      特点：类加载的时候会执行，只执行1次
      不能访问普通成员变量
      静态代码块先于构造代码块执行
      静态代码块和显示的声明静态变量谁在前面谁先执行
静态导入
  格式
    import static 类的全包名.static的成员方法;
    import static 类的全包名.static的成员变量;
    import static java.lang.Math.random;
    import static java.lang.Math.PI;
  使用静态导入可以简化代码
继承
  继承是属于类与类之间的一种关系
  继承是面向对象语言的三大特征之一 
  java中类继承是单继承，一个子类只能继承一个父类(一个父亲)
  java中不能多继承，以下代码编译报错
    public class Student extends Person,Animal
  多层继承
    子类A继承父类B，
    父类可以继承爷爷类C
    A extends B{}
    B extends C{}
  java中接口是多实现，一个接口能实现多个接口(老师、师傅)
  动物类
    狗类
    猫
    熊猫
    鳄鱼
    Person类
      Teacher类
      Student类
  继承的实现
    [public] class 子类名 extends 父类名{
      // 可以直接继承父类的属性和方法
      // 实现子类的新增内容
    }
  父类：也称为 基类、 超类 super
  子类：派生类
  子类能够继承父类的属性，但是如果父类的属性是私有的，那么子类无法直接访问
  子类只能继承父类的所有非私有的成员变量和成员方法
  官方文档：
  从继承的概念来说，private修饰的成员不被继承，
  但是，如果超类中具有访问其私有字段的非私有（公开、受保护）方法，那么子类也可以使用这些方法
  子类如何访问父类中的私有成员变量？
  static成员变量或方法
    访问性：如果子类中没有定义与父类同名的成员变量或方法，那么子类可以访问父类中的静态变量和方法
    如果子类中定义了与父类同名的成员变量或方法，那么子类访问的是自己的静态变量和方法
    虽然静态成员不是通过继承机制获得的，但子类可以通过继承获得访问父类静态成员的权限
Object类
  toString();
  java中类如果没有指明继承的父类，那么默认继承Object类
    public class Animal {
      编译后
    public class Animal extends Object{
  Object类中没有成员属性，只有方法
  常用的就是toString()、equals()
  是java继承体系中的最顶层父类
继承的优点和缺点
  优点
    提高代码的复用率
    提高代码的维护性 小问题的话 修改父类一处即可，不需要到每个子类中修改
  缺点
    代码与代码之间存在关联，这种关系叫耦合
    继承，让类与类之间产生了耦合，降低代码的灵活性，父类如果有变化，子类不得不适应
super
  父类非private成员和子类的成员变量重名，如何区分？
  super表示子类从父类中继承的那部分的引用
在子类方法中访问一个变量，根据就近原则
  局部变量 子类的成员变量 父类的成员变量
  如果非要访问指定的变量 this或者super去指定
构造方法
  子类对象成员包含两类
    继承部分
      this.number = number;
      // this.name = name;  setXXX();
    新增部分
      this.number = number;
    如果参数比较少，可以直接赋值 如果是私有属性，可以调用父类的非私有的set方法，如果属性非常多，那么要用构造器
  子类构造器中如果调用父类构造器，必须为第一行有效代码
  子类构造器中如果调用父类构造器，父类中必须提供，否则会编译错误
重载
  类中 同名方法 参数列表（数量、类型都算）不同，与返回值类型无关 
重写
  继承关系中，当子类需要父类的功能，而继承的方法不能完全满足需求，可以重写父类的方法，这样沿袭了父类的功能，又定义了子类特有的内容
  特点
    子类和父类方法名要相同
    参数列表要完全相同
    方法的返回值类型可以相同，可以不同（先按相同处理，不同的情况后面补充）
    异常类型的抛出的范围可以缩小，不能扩大（后面补充）
    权限修饰符范围可以扩大，不能缩小
      public protected default private
    子类继承父类，在调用方法时，如果子类中有重写，那么就用重写的方法，
    如果没有重写，就用父类中的方法。
    父类中的私有方法(未被继承),不能被子类重写
    静态成员方法不能被子类重写
    因为Object是顶级父类，那么比如toString()方法能被所有类的对象直接使用
    @Override 注解
    作用： 提供了一种额外的检查机制和代码清晰度。
      1. 代码层面提醒程序员注意编程规范：重写、接口的实现
      2. 编译器检查 检查是否是重写 有助于尽早发现错误
    重写 toString 方法
    final 最终
      final修饰的方法不能被重写
单例模式
  是一种设计模式，保证一个类只有一个实例，提供一个全局访问的方式。
  所以这个类只有一个对象可以被创建
  在程序的所有部分都可以访问到这个对象
final
  final修饰的类  不能被继承   那么如果非要去继承，报什么错？
  final修饰的方法不能被重写， 可以被继承吗？
  final修饰的属性（变量）的值不能更改 常量
    数据类型：基本 值不能修改
            引用 地址值不能修改，地址对应的内容是可以改变的
  1.final修饰的类  不能被继承 ，那么如果非要去继承，报什么错？
  2.final修饰的方法不能被重写，可以被继承
  3.String 类可否被继承？ 不可以 final修饰的
  4.final修饰的属性（变量）的值不能更改，如果非要去更改，报什么错？
权限修饰符
  public      公共的 在所有地方都可以访问
    public class
  protected   受保护的 当前类、子类、同一个包中的其他类
     protected class
  default   （指默认 default不是一个修饰符）默认 当前类、子类
    class
  private     私有的 当前类
多态
  面向对象语言的三大特征之一
  一种事物，有多种状态
  java中多态怎么实现
    子类继承父类
    子类要重写父类的方法
    父类的引用指向子类对象（一个父类的引用可以指向任何一个子类的对象）
      Animal a = new Dog();
    父类的引用调用子类重写的方法
  java中完全相同的代码出现在不同的位置，执行的结果不同
    point.show();
高内聚，低耦合
开闭原则
  面向对象设计中的一条基本原则，软件实体（类、模块、函数等）对扩展是开放的，对修改是关闭的。
  当需求发生变化时，应该通过新增代码来实现 ，而不是修改代码，所以一般要结合多态的思想，处理这个问题
数据类型转换  
  引用类型转换
    向上转型（隐式转换） 父类引用指向子类对象
      父类 引用名 = 子类对象; 
      Point point = new Circle(1, 1, 2);
      Animal a = new Dog();
    向下转型（显式转换） 子类引用指向父类对象，
    前提：父类对象本身就是子类类型
    如果被转的引用类型变量，对应的实际类型和目标类型不是同一种类型，那么在转换的时候就会出现运行时异常，ClassCastException异常
    Fork f = (Fork)b; 强制转换时，b实际指向Derived对象，Derived和Fork类型不是子父类关系，所以它是不能转为Fork对象的！
      Person p1 = new Student();
      Student s1 = (Student)p1;  // 向下转型
向上转型的特点
  // 向上转型 子类对象指向父类引用
  Base base = new Derived();
  成员变量：编译的时候看左边（父类），运行的时候看左边（父类）
  成员方法：编译的时候看左边（父类），运行的时候看右边（子类）
  向上转型时，父类引用无法调用子类独有的成员变量和成员方法
向下转型的特点
  // 向下转型
  Derived d = (Derived) base;
  向下转型时，可以访问子类独有的成员变量和成员方法
抽象
  在面向对象编程中，抽象是通过定义类、接口和方法来实现的，
  抽象方法
    将共同的方法抽取到父类中后，发现这个方法在父类中没有具体的实现逻辑，无法具体的实现，此时就可以把这个方法定义为抽象方法。
    抽象方法只有声明 没有实现 没有方法体{}
    public abstract void eat();
    正常（非抽象）子类必须重写父类所有的抽象方法，
    报错信息：Cat不是抽象的, 并且未覆盖Animal中的抽象方法sleep()
  抽象类
    包含抽象方法的类，那么必须声明为抽象类。
    抽象类可以包含抽象方法，也可以不包含抽象方法
    关键字 abstract
    public abstract class Animal
    抽象类可以包含成员属性、成员方法、构造器等内容
    抽象类不可以实例化对象
  普通类和抽象类的区别
    抽象类必须使用修饰符abstract
    相对于普通类，可以包含抽象方法
    相对于普通类，失去了实例化创建对象的能力
  普通类和抽象类的相同点
    可以继承、多态、重写、有构造器、有成员变量、方法
接口interface
  特点
    引用数据类型中的一种：类 接口 数组
    java中的接口是对单继承的一个补充，在开发过程中想增强类的功能，可以借助接口去实现，接口是多实现（比如一个人可以有多个老师）
    接口文件编译后生成.class 但是接口和类不是同一种东西
    public interface IAction {}
    注意1， 定义类使用关键字 class ，定义接口使用关键字 interface
    注意2，接口中的数据成员，默认 public static final 修饰，是常量，名称一般全大写
    注意3，接口中的方法，默认 public abstract 修饰，是抽象方法
    接口和类不一样，接口不可以实例化对象，没有构造方法
    接口是用来实现的，而不是继承
    接口是多实现的，但是
    接口的实现类要重写接口的所有抽象方法
    Java中类的继承是单继承，接口和接口之间是多继承
类与接口的区别
  类与类之间是单继承、但是是多层继承
  类与接口之间是实现关系，一个类可以在继承一个类的情况下，同时实现多个接口
  接口和接口之间的关系
    继承关系，可以单继承，也可以多继承
接口的新特性
  jdk8中，接口可以添加默认方法和静态方法，
  但是静态方法，只能通过接口名调用
  jdk9中，接口中可以添加私有方法，在jdk1.8中报错
内部类
  在一个类的内部定义另外一个类，就是内部类
  编译后，外部类和内部类都会生成字节码文件
  内部类的使用：
    1. 比如ArrayList中 就有多个内部类的使用
    2. 类与类之间的包含关系 比如汽车类 包含发动机 发动机也是一个类 此时就可以使用内部类的概念来处理这种关系
  分类
    成员内部类
    静态内部类
    局部内部类
    匿名内部类
成员内部类 
  在类中，可以定义成员属性、成员方法，还可以定义成员内部类
  成员内部类的定义位置：类中，方法外
  在成员内部类中不能定义静态成员变量和成员方法
  实例化一个内部类 Inner 的对象
    外部类名.内部类名 对象名 = 外部类对象.内部类对象;
    Outer.Inner inner = new Outer().new Inner();
    Outer.Inner inn = this.new Inner();

    // 创建一个外部类的对象
    Outer out = new Outer();
    // 创建一个内部类的对象
    Outer.Inner inn = out.new Inner();
    Outer.Inner inn2 = new Outer().new Inner();
  在外部类中实例化自己的成员内部类对象的3种方式
    1. Outer.Inner inner = new Outer().new Inner();
    2. Outer.Inner inner = this.new Inner();
    3. Inner inner = new Inner();
  编译后，外部类和内部类都会生成字节码文件
    Outer.class
    Outer$Inner.class
静态内部类  
  定义在类中，方法外；
  用static修饰的成员内部类叫静态内部类
  静态内部类中成员方法，只能访问外部类中的静态成员或静态方法。
  在成员内部类中不能定义静态成员变量和成员方法，在静态内部类中，可以定义静态成员和静态方法
  外部类的方法是能访问静态内部类的所有成员和方法
局部内部类 (很少使用)
  定义在类中的方法中
  在外部类的方法中定义的内部类，叫局部内部类，作用范围在当前方法中
  从内部类引用的本地变量必须是最终变量或实际上的最终变量 final
匿名内部类（重点掌握） 
  定义
    没有名字的内部类，也是特殊的局部内部类（定义在方法内部）
    定义位置要结合使用场景考虑
      Animal animal = new Animal("狗子") {
        // 匿名内部类的实现
      }
  使用场景
    实现接口
      利用接口进行声明并创建匿名内部类对象，这个匿名内部类默认就是接口的实现类
    继承抽象父类  
      利用父类进行声明并创建匿名内部类对象，这个匿名内部类就是父类的子类
  核心任务
    匿名内部类的核心任务是重写抽象方法，然后就可以调用重写的方法
  注意事项
    匿名内部类必须依托于一个接口或者一个父类（可以是抽象类，也可以是普通类）
    匿名内部类在声明的时候就要去创建对象，否则后面无法调用（比如简化的写法，只能调用一次）
    匿名内部类中无法定义构造器
  匿名内部类使用父类构造器的方法
  Animal animal = new Animal("狗子") {
    // 匿名内部类的实现
  }



 

  

总结梳理程序启动后代码中的各种方法的执行顺序以及执行次数？

注意：
  1. 修改改环境变量
   1. 三个确定按钮都要点
   2. 重新打开cmd、vscode
  2. 编码
    1. 先保存
    2. 先编译 再运行
  3. 中文乱码 VScode右下角 改为GBK
  4. 找不到主类
    1. 字节码文件生成没有
    2. java HelloWorld 命令对不对 文件名对不对
    3. CLASSPATH 的值不要写错 可以不写 或者写 .
  5. java项目报错的话，一般从上往下解决
练习打字
  1. 键位 指法（金山打字通） 新手
  2. 多打字（聊天、打一些熟悉的文章）
  3. test Test 临时大写可以按住shift键
  4. 12345

总结学习过程中遇到的所有报错
  编译型错误
    javac 
  运行时错误  
    java

从键盘录入一个年份值 判断并输出是否为闰年
需要使用 % == || 等操作符以及if-else语句

键盘输入一个整数 0-6 输出是星期几
  0 星期日
  1 星期一
键盘录入一个年份和一个月份，输出该月份有多少天
  要求：  
   用switch case

键盘录入一个整数，求从1到这个数的整数之和
比如录入的是5 1+2+3+4+5=？

小芳的妈妈每天给她2.5元钱，她都会存起来，但是，每当这一天是存钱的第5天或者5的倍数的话，她都会花去6元钱，请问，经过多少天，小芳才可以存到100元钱。
  使用break;continue

求数组元素的平均值
要求：
  实现一个方法参数是int[]，该方法可以计算出数组中所有数据的平均值并返回自己随机创建一个数组，并验证结果

求数组最大值
实现一个方法，参数是int[]，该方法可以计算出数组中所有数据的最大值并返回
创建一个数组，并验证结果

定义一个方法 传递一个数组对象给它 将这个数组长度扩大到原来的2倍，并返回

定义一个方法 可以求和 求平均数 的功能 要使用可变参数列表
  myTest("sum",1,2,3);
  myTest("avg",arr);
  // myTest("max",1,2,3);
创建一个int类型的二维数组，求和

定义一个手机类，属性含品牌、价格，具备打电话、发短信的功能。
再定义一个手机测试类，在手机测试类中通过对象完成成员变量和成员方法的使用。

  定义一个动物类
    属性包含：
      颜色、年龄、名字
      种类 ：猫、狗等
      等
    方法：
      sayHello()
      我是 狗子 ，我的名字是 点点， 我的年龄是 1 岁，我的颜色是 白色。 
      eat()
        猫 吃 鱼
        狗 吃 肉
        熊猫 吃 竹子
    再定义一个动物测试类，在测试类中通过对象完成成员变量和成员方法的使用。

定义一个学生类，
  属性包含：

  功能包含：
    学习
    考试挂科
    吃饭
    玩游戏
    等
再定义一个测试类，在测试类中通过对象完成成员变量和成员方法的使用。

Teacher类
  成员变量 
    姓名
    性别
    工号
  利用封装的特点 提供对应的get set方法
  提供对应的 sayHello 或者 show 或者toString 的方法 输出这个对象的全部属性
  提供三个构造器
    无参 两个参数 三个参数（调用两参构造器） 
  然后使用不同的构造器创建3个对象 
  调用这些方法

查找
  精确查找
    id  
  模糊查询
    名字  
新增  
  id要自动生成，防止id重复
  或者
  id也可以用户自己设置，但是设置的时候要查询有没有重复的

动物类
    成员方法
      吃东西
      睡觉
    猫类
      继承重写父类的方法
    狗类
      继承重写父类的方法
  在 Java/day19 文件夹中创建基类和派生类 然后编译到day19/class文件夹中 然后运行
    父类中的eat和sleep是不明确的两个方法，一般通过抽象方法和抽象类体现这种不明确

定义一个抽象父类Animal2
再定义两个接口
  IJumpAble跳火圈、
  ICycleAble骑自行车，
最后定义一个猴子类Monkey，去继承Animal2，同时实现IJumpAble、IJumpAble，
进行功能测试。
